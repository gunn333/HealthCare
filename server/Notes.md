# JWT

-   Jwt is a token that is used to authenticate users on the web
-   Client sends a request with his headers and the server sends a response back with a jwt token
-   The server verifies the jwt token and sends a response back to the client
-   Client will store the token in the local storage
-   How to store in local storage : localStorage.setItem('token', tokenvalue)
-   Aise hi hum session cookies mein bhi store kar sakte hain
-   How to store in session cookies : res.cookie('token', tokenvalue, {httpOnly: true})
-   Difference between Authentication and Authorization
-   Authentication is the process of verifying the identity of a user
-   Authorization is the process of determining what a user is allowed to do after they have been authenticated (e.g. access a resource, perform an action)
-   For example, when a user logs in to a website, they are authenticated by providing their username and password (authentication)
-   Once the user is authenticated, the website determines what the user is allowed to do based on their role or permissions (authorization)
-   RBAC : Role Based Access Control
-   RBAC is a method of restricting access to resources based on the roles of users
-   For Login, Request will be sent to the server with the username and password
-   Server will check the username and password in the database and if it is correct, it will generate a jwt token and send it back to the client
-   Stateful vs Stateless Authentication
-   Stateful Authentication : The server maintains the state of the user's session on the server
-   For example, when you log into a website, the server keeps track of your login session and other actions (like items in your cart).
-   Stateless Authentication : The server does not maintain the state of the user's session on the server
-   Stateless mein DB mein data store nahin hota, stateful mein store hota hai
-   Stateful is better for user-specific applications, where sessions and user state need to be tracked across interactions for a personalized or complex user experience.
-   Stateless is generally more suitable for large-scale applications, APIs, microservices, and systems that require high availability and scalability.
-   Stateful: In a stateful system, data can be stored either on the server or client-side, but the key point is that the server keeps track of the user's state. This means the server stores session data (e.g., login information, shopping cart contents) so that it can remember previous interactions during the user's session.
-   Stateless: In a stateless system, the server does not store any state information. Each request sent by the client is independent, meaning all the data needed for processing the request is sent along with the request (usually in the form of tokens or parameters), and the server does not "remember" anything from previous requests.
-   Structure of JWT Token : JWT tokens are composed of three parts: a header, a payload, and a signature.
-   The header typically consists of two parts: the type of the token, which is JWT, and the signing algorithm being used, such as HMAC SHA256 or RSA.
-   The payload contains the claims, which are statements about an entity (typically, the user) and additional data. basically payload is the data that is stored in the token like user id, username, etc.
-   The signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn't changed along the way.

-   Jwt has two methods : sign and verify

-   Sign has three parameters : payload, secretkey, and options
-   Verify has three parameters : token, secretkey, and callback function
-   options mein kya jaega : agar hum koi token create kr re hai toh uski expiry date kis time tak ki hai, uska algorithm kya hai, etc.
-   To get the secret key from env file : process.env.SECRET_KEY
-   payload mein data jaega user ka and if error hai toh console.log(err.message) else console.log(success)
-   Sign is used to generate a jwt token and verify is used to verify the jwt token that is generated by the sign method
-   Sign : jwt.sign({payload}, secretkey, {expiresIn: '1h'})
-   Verify : jwt.verify(token, secretkey, (err, data) => {})
-   Other method : jwt.decode(token) means to decode the token like what is inside the token
-   We need to refresh the token after a certain period of time because the token expires after a certain period of time

-   Which routes need to be secure and which routes need to be not secure and why
-   The routes that need to be secure are the routes that are used to access the sensitive data of the user
-   For example, the routes that are used to access the user's personal information, the routes that are used to access the user's financial information, etc.
-   These routes need to be secure because if these routes are not secure, then the sensitive data of the user can be accessed by unauthorized users
-   The routes that need to be not secure are the routes that are used to access the public data of the user
-   For example, the routes that are used to access the user's public profile, the routes that are used to access the user's public posts, etc.

-   What is the difference between HTTP and HTTPS

-   HTTP stands for Hypertext Transfer Protocol
-   HTTPS stands for Hypertext Transfer Protocol Secure
-   HTTP is used to transfer data between the client and the server while HTTPS is used to transfer data between the client and the server securely

## MiddleWare

-   Middleware are basically functions that have access to the request object (req), the response object (res), and the next middleware function in the applicationâ€™s request-response cycle. The next middleware function is commonly denoted by a variable named next.
